--                                  Método fill()
El método fill() en Laravel es una forma conveniente de asignar valores masivos a los atributos de un modelo, siempre y cuando los atributos estén definidos como "asignables en masa" (mass assignable) en el modelo correspondiente. Esto se utiliza a menudo cuando se reciben datos desde formularios o API y necesitas asignarlos directamente a un modelo.
Para que fill() funcione, los atributos deben estar incluidos en la propiedad $fillable del modelo.


--                              ¿Qué hace attach()?
El método attach() en Eloquent es utilizado para insertar registros en la tabla pivote.

$producto->categorias()->attach($categorias)

Ejemplo práctico: Si $categorias = [1, 2] y el producto tiene ID 5, Laravel creará las siguientes filas en la tabla pivote:   
+-------------+----------------+
| producto_id | categoria_id   |
+-------------+----------------+
| 5           | 1              |
| 5           | 2              |
+-------------+----------------+


Resumen:
Una tabla pivote sirve para representar relaciones "muchos a muchos".
attach() inserta registros en la tabla pivote para asociar modelos.
Si necesitas evitar duplicados o reemplazar asociaciones, puedes usar sync().


--                                $proveedore->load('persona.documento')
load() se utiliza para cargar la relacion que tiene una clase con otra, en este caso sería traer la relacion de cliente con persona.

¿Por qué se necesita llamar otra vez a las relaciones que tiene la clase proveedore('persona.documento') si ya hice eso en la función index?
La razón por la que necesitas usar nuevamente $proveedore->load('persona.documento') en la función edit es porque Laravel no mantiene automáticamente las relaciones cargadas entre diferentes solicitudes HTTP, básicamente laravel no te trae las relaciones que cargaste amteriormente en la función index

🚀 ¿Por qué ocurre esto?
Cuando llamas a la función index(), usas Eager Loading con Proveedore::with('persona.documento') para obtener todos los proveedores con sus relaciones. Eso funciona porque la consulta se ejecuta en ese momento y esos datos se envían a la vista index.blade.php.

Sin embargo, al hacer clic en el botón Editar, envías una nueva solicitud HTTP GET a la ruta proveedores.edit. En esa solicitud:

Se pasa solo el ID del proveedor a través de la ruta (gracias al route model binding de Laravel).
Laravel busca el proveedor usando ese ID (Proveedore $proveedore), pero solo carga los datos de la tabla proveedores, sin incluir relaciones como persona o documento.

💡 ¿Por qué no se mantienen las relaciones?
Cada solicitud HTTP en Laravel es independiente. La información de una solicitud (como las relaciones cargadas en index) no se guarda automáticamente para la siguiente solicitud (como en edit).

Por eso, necesitas hacer:

$proveedore->load('persona.documento');

Esto le indica a Laravel:

"Además de los datos del proveedor, también quiero las relaciones persona y documento para este registro en particular."
⚡ ¿Cómo evitarlo?
Si quisieras evitar cargar la relación de nuevo, tendrías que:

Enviar todos los datos a la vista de edición usando POST o session, lo cual no es recomendable por temas de seguridad y rendimiento.
Usar AJAX para cargar los datos de edición sin una nueva solicitud completa, pero esto añade más complejidad.
✅ Conclusión:
Debes usar $proveedore->load('persona.documento') en el método edit porque cada solicitud HTTP es un proceso nuevo, y Laravel no mantiene los datos cargados previamente.





--                                      cuando  usar with() y cuando usar load()
1-🔗 with() (Carga Eager, antes de la consulta)
¿Cuándo se usa?
Se usa cuando vas a hacer la consulta a la base de datos.
¿Cómo funciona?
Laravel hace una sola consulta (o consultas optimizadas) para traer tanto el modelo principal como sus relaciones.
Ejemplo:

$proveedores = Proveedore::with('persona.documento')->get();

Aquí Laravel está diciendo:
"Voy a buscar todos los proveedores y al mismo tiempo traer la relación persona.documento."

¿Cuándo es útil?
Cuando necesitas muchos registros con sus relaciones (por ejemplo, en una tabla como index).
Ventaja:
Menos consultas a la base de datos → más eficiente cuando cargas muchos datos.


2-🔄 load() (Carga Lazy, después de la consulta)
¿Cuándo se usa?
Se usa después de haber obtenido el modelo de la base de datos.
¿Cómo funciona?
Laravel hace una consulta adicional solo para traer la relación.
Ejemplo:

$proveedore = Proveedore::find($id);

$proveedore->load('persona.documento');
Aquí Laravel primero dice:
"Voy a buscar el proveedor con ID X." (primer consulta)
Luego:
"Ahora que tengo el proveedor, voy a buscar su relación persona.documento." (segunda consulta)

¿Cuándo es útil?
Cuando ya tienes el modelo cargado y solo necesitas la relación en ese momento específico (por ejemplo, en edit).
Ventaja:
Más flexible para casos donde no sabías al principio si ibas a necesitar la relación

🚀 ¿Por qué usaste load() en edit()?
Cuando entraste en edit(), Laravel ya tenía el proveedor, pero sin la relación cargada porque solo habías enviado el ID.
Por eso le dijiste: "Oye Laravel, carga esta relación ahora" usando load().

En cambio, en index(), como querías todo desde el principio, usaste with() para traerlo todo de una vez.

🚀 ¿Entonces cuándo usar cada uno?
✅ with() → Para listas grandes (como en index).

Más eficiente, menos carga en la base de datos.
✅ load() → Para detalles individuales (como en edit).

Perfecto cuando ya tienes el modelo y necesitas la relación en ese momento.


--                                          Cuando utilizar all() y with()
📌 ¿Cuándo usar all()?
all() solo es recomendable si:

✅ La tabla tiene muy pocos registros (menos de 50).
✅ No necesitas cargar relaciones.
✅ Quieres obtener absolutamente todos los registros sin filtros.
✅ Pero en la mayoría de los casos, es mejor usar get() con with() para evitar problemas de rendimiento.

📌 ¿Cuándo usar with()?
Usa with() cuando: 
✅ Vayas a acceder a relaciones en la vista.
✅ Quieras evitar el problema de N+1 queries.
✅ Necesites filtrar registros basados en relaciones (whereHas()).
✅ Uses paginación (paginate() o simplePaginate()).
✅ Quieras cargar múltiples relaciones al mismo tiempo.
✅ Construyas una API y necesites devolver relaciones optimizadas.

🔹 Regla general: Si vas a usar relaciones en cualquier parte de tu código, usa with() para mejorar el rendimiento y evitar consultas innecesarias. 🚀



--                              Si tienes más de 50 registros pero no necesitas cargar relaciones, puedes usar get() en lugar de all().

📌¿Por qué usar get() en vez de all()?
all() trae todos los registros y los carga en memoria como una colección. Si tienes miles de registros, esto puede consumir mucha RAM y ralentizar la aplicación.
get() obtiene los registros directamente desde la base de datos sin convertirlos en una colección de inmediato, lo cual es más eficiente.
Ejemplo recomendado:

$productos = Producto::get(); // En lugar de Producto::all()

✅ Esto mejora el rendimiento si tienes muchos registros porque evita el uso innecesario de memoria.

📌¿Cuándo sí puedes usar all()?
Puedes usar all() sin problema si:

Tienes pocos registros (menos de 50-100).
Sabes que la cantidad de datos no aumentará drásticamente.
Necesitas una colección de inmediato (porque all() devuelve una colección en lugar de una consulta SQL).
🔹 Regla general:

✅Si son pocos registros → Usa all().
✅Si son muchos registros y no necesitas relaciones → Usa get().
✅Si necesitas relaciones → Usa with() con get(). 🚀

--                          El método whereHas()
El método whereHas() en Laravel se usa para filtrar registros según una relación, asegurando que solo se devuelvan aquellos registros cuyo modelo relacionado cumpla con una condición específica.
Por ejemplo: 
$proveedores = Proveedore::whereHas('persona',function($query) {
            $query->where('estado',1);
        })->get();



--              $producto->categorias()->attach($categorias);

//El método attach() es utilizado para insertar registros en la tabla pivote.

--              $compra->productos->syncWithoutDetaching([]);

//syncWithoutDetaching() es un metodo que te permite añadir registros a la tabla pivote

--          La diferencia clave entre attach() y syncWithoutDetaching()
En Laravel, cuando trabajas con relaciones de muchos a muchos, los métodos attach() y syncWithoutDetaching() en Eloquent tienen diferencias clave en cómo manejan la asociación de registros en la tabla intermedia.

🔹 attach($ids, $attributes = [], $touch = true)
Agrega una relación entre modelos en una tabla pivote.
No verifica duplicados, lo que significa que si intentas agregar un mismo registro varias veces, puedes terminar con entradas duplicadas en la tabla pivote.
Si deseas agregar datos adicionales en la tabla pivote, puedes pasarlos como el segundo parámetro ($attributes).
Ejemplo:

$user->roles()->attach(1); // Agrega el rol con ID 1 al usuario
$user->roles()->attach([1, 2, 3]); // Agrega varios roles

🔹 syncWithoutDetaching($ids, $attributes = [])
Agrega nuevos registros sin eliminar los existentes.
Evita duplicados, porque Laravel verifica si la relación ya existe antes de agregarla.
Mantiene las relaciones previas, a diferencia de sync(), que elimina las relaciones no incluidas en la lista de IDs.
Ejemplo:

$user->roles()->syncWithoutDetaching([2, 3]); // Agrega los roles 2 y 3 sin eliminar otros existentes

📌 Diferencias clave:
Método	              |  Agrega registros   |  Evita duplicados    |  Mantiene relaciones previas
attach()              | ✅ Sí               |❌ No	            |✅ Sí
syncWithoutDetaching()|	✅ Sí	           |✅ Sí	            |✅ Sí

Si deseas agregar sin riesgo de duplicados, usa syncWithoutDetaching(). Si solo necesitas agregar sin preocuparte por eso, usa attach(). 🚀


--                          Ejemplo de usar el syncWithoutDetaching():

🔹 Ejemplo en tu código:

$compra->productos->syncWithoutDetaching([
    $arrayProducto_id[$cont] => [  // ID del producto como clave
        'cantidad' => $arrayCantidad[$cont],       // Guardado en la tabla pivote
        'precio_compra' => $arrayPrecioCompra[$cont], // Guardado en la tabla pivote
        'precio_venta' => $arrayPrecioVenta[$cont]    // Guardado en la tabla pivote
    ]
]);

Esto significa que en la tabla pivote (compra_producto), además de los compra_id y producto_id, se almacenarán los valores de cantidad, precio_compra y precio_venta. Cuando usas syncWithoutDetaching(), puedes pasar un array asociativo con los datos adicionales(cantidad, precio_compra y precio_venta) que se guardarán en la tabla pivote.Aquí, cada $arrayProducto_id[$cont] es la clave del array, y su valor es otro array con los datos adicionales que quieres guardar en la tabla pivote.

🔹 Ejemplo práctico:

Datos de entrada ($request)

$arrayProducto_id = [1, 2, 3]; 
$arrayCantidad = [5, 10, 3];
$arrayPrecioCompra = [100, 150, 80];
$arrayPrecioVenta = [120, 180, 100];

Cómo se ve en syncWithoutDetaching() en cada iteración:

$compra->productos->syncWithoutDetaching([
    1 => ['cantidad' => 5, 'precio_compra' => 100, 'precio_venta' => 120],
    2 => ['cantidad' => 10, 'precio_compra' => 150, 'precio_venta' => 180],
    3 => ['cantidad' => 3, 'precio_compra' => 80, 'precio_venta' => 100]
]);



--                      Explicacion del codigo de la funcion create de venta controller


        $subquery = DB::table('compra_producto')->select('producto_id', DB::raw('MAX(created_at) as max_created_at'))->groupBy('producto_id');
        
        $productos = Producto::join('compra_producto as cpr', function ($join) use ($subquery) {
            $join->on('cpr.producto_id', '=', 'productos.id')->whereIn('cpr.created_at', function ($query) use ($subquery) {
                $query->select('max_created_at')->fromSub($subquery,'subquery')->whereRaw('subquery.producto_id = cpr.producto_id');
            });
        })->select('productos.nombre', 'productos.id', 'productos.stock','cpr.precio_venta')->where('productos.estado',1)->where('productos.stock', '>',0)->get();

🔹 Línea 1: Iniciar la consulta
$productos = Producto::join('compra_producto as cpr', function ($join) use ($subquery) {}) 

📌 Explicación:
✅Producto::join(...) → Realiza un JOIN entre productos y compra_producto (renombrado como cpr).
✅function($join) use ($subquery) { ... } → Esto es una función anónima que define la lógica del JOIN. La palabra clave use ($subquery) permite acceder a la subconsulta $subquery dentro de la función.

🔹 Línea 2: Condición del JOIN
$join->on('cpr.producto_id', '=', 'productos.id')

📌 Explicación:
✅on(...) establece la condición de unión entre tablas: cpr.producto_id (de la tabla compra_producto), productos.id (de la tabla productos)
Esto significa: "Vincula cada producto con su historial de compras".

🔹 Línea 3-4: Filtro para obtener solo la compra más reciente
->whereIn('cpr.created_at', function ($query) use ($subquery) {})

📌 Explicación:
✅whereIn('cpr.created_at', function ($query) use ($subquery) { ... }):
    Filtra las compras (compra_producto) y solo permite las compras más recientes.
    La subconsulta $subquery se usa para obtener las fechas más recientes.

🔹 Línea 5: Subconsulta dentro del whereIn
$query->select('max_created_at')
      ->fromSub($subquery, 'subquery')
      ->whereRaw('subquery.producto_id = cpr.producto_id');

📌 Explicación:
select('max_created_at') → Selecciona la fecha más reciente de cada producto.
fromSub($subquery, 'subquery') → Usa la subconsulta como si fuera una tabla.
whereRaw('subquery.producto_id = cpr.producto_id')
Relaciona la subconsulta con la tabla compra_producto asegurando que se comparen correctamente.


📌 Consulta Principal, esta consulta es lo mismo que el codigo de arriba
Ahora unimos productos con compra_producto, solo considerando la última compra de cada producto.

SELECT productos.nombre, productos.id, productos.stock, cpr.precio_venta
FROM productos
JOIN compra_producto as cpr
    ON cpr.producto_id = productos.id
WHERE cpr.created_at IN (
    SELECT max_created_at
    FROM (
        SELECT producto_id, MAX(created_at) as max_created_at
        FROM compra_producto
        GROUP BY producto_id
    ) AS subquery
    WHERE subquery.producto_id = cpr.producto_id
)
AND productos.estado = 1
AND productos.stock < 0;


-- Autenticación de usuario, explicacion del codigo:

        if(!Auth::validate($request->only('email','password'))) { 
                    return redirect()->to('login')->withErrors('Credenciales incorrectas');
        }
        
        //CREAR UNA SESIÓN

        $user = Auth::getProvider()->retrieveByCredentials($request->only('email','password'));//Esta línea busca al usuario en la base de datos utilizando las credenciales (email y password)
        Auth::login($user);

        return redirect()->route('panel');


✅$user = Auth::getProvider()->retrieveByCredentials($request->only('email','password'))
📌¿Qué hace?
Esta línea busca al usuario en la base de datos utilizando las credenciales (email y password), pero NO verifica la contraseña( debido a que ya se verificó en el if() la contraseña) ni inicia sesión todavía.

✅Auth::login($user);
📌¿Qué hace ?
Inicia sesión con ese usuario. Es decir, Laravel:
* Lo autentica como el usuario activo.
* Crea la sesión.
* Guarda su ID en la sesión (para recordarlo en las próximas peticiones).

-- 📌 ¿Qué hace Auth::check()?
Este método verifica si ya hay un usuario autenticado (logueado) en la sesión.

Devuelve true si el usuario ya está logueado.

Devuelve false si no hay ningún usuario autenticado (por ejemplo, si recién abrió la página o cerró sesión).    



-- cual es la diferencia entre assign y sync
//Asignar su rol
            $user->assignRole($request->role);
//Actualizar el rol
            $user->syncRoles([$request->role]);

🔹 assignRole($role)
Agrega uno o más roles al usuario. No elimina los roles anteriores. Ideal si el usuario puede tener múltiples roles y quieres añadir uno nuevo sin quitar los demás.

$user->assignRole('admin'); // si ya tenía 'editor', ahora tendrá ambos: 'editor' y 'admin'

🔹 syncRoles([$role])
Reemplaza todos los roles del usuario por los que le pases. Elimina los roles anteriores que no estén en el nuevo arreglo. Ideal si el usuario debe tener solo un rol activo.

$user->syncRoles(['admin']); // si tenía 'editor', se lo quita y solo queda 'admin'


✅ ¿Cuál usar?
Usa assignRole() si el usuario puede tener más de un rol al mismo tiempo.

Usa syncRoles() si el usuario debe tener solo un rol a la vez (caso más común en muchos sistemas).

